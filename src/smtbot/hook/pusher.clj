(ns smtbot.hook.pusher
  {:clj-kondo/config  '{:linters {:unused-referred-var
                                  {:exclude {taoensso.timbre [log  trace  debug  info  warn  error  fatal  report
                                                              logf tracef debugf infof warnf errorf fatalf reportf
                                                              spy get-env]}}}}}
  (:require  [cheshire.core :as json]
             [org.httpkit.client :as http]
             [smtbot.dal.globals :as g]
             [taoensso.timbre :as timbre
              :refer [log  trace  debug  info  warn  error  fatal  report
                      logf tracef debugf infof warnf errorf fatalf reportf
                      spy get-env]]
             [taoensso.timbre.appenders.core :as appenders]
             [clojure.string :as str]
             [clojure.core.async
              :as a
              :refer [>! <! >!!  go  chan  close!
                     ; <!!  go-loop alts! alts!! timeout buffer sliding-buffer thread
                      ]]
             [smtbot.http_errors :as http-errors]
             [smtbot.hook.globals :refer [fetch-marker online-messangers]]))



(defn build-opts [{:keys [url method body id headers]}, thread]
  {:url url
   :method (keyword method)
   :body body
   :thread thread
   :rec-id id
   :headers (json/parse-string headers)})


(defn pusher-factory
  "Return message pusher. 
   Depends on  async-pusher-enabled created  generates async or sync pusher.
   Pusher generated by async factory uses async http request pushing task to sm.
   Pusher factory requers the following parameters to create pusher:
    mode - one of :user-mode, :global-mode or async-mode 
    get-allowed - true or false, make sence for :user-mode only, allow user place get request 
    config -  global configuration, in most cases thes best choise is (config/get-config)
    workers -  workers configuration, in most cases thes best choise is (config/get-workers) 
   "
  [async-pusher-enabled]
  (if (true? async-pusher-enabled)
    (fn [message thread write-channel-callback]
      (debugf "Send message %s\n - source %s\n - options %s" (:id message) message (build-opts message thread))
      (http/request (build-opts message thread) write-channel-callback))
    (fn [message thread]
      (debugf "Send message %s\n - source %s\n - options %s" (:id message) message (build-opts message thread))
      @(http/request (build-opts message thread)))))



(defn- write-channel-callback-factory [channel]
  (fn [resp]
    (>!! channel resp)))

(defn- exit-thread [^String id]
  (let [pusher-id ((str/split id #"\/" 2) 0)]
    (if (some? (@online-messangers pusher-id))
      (reportf  "Thread %s exited, %s threads left." id
                (((swap! online-messangers update-in [pusher-id :threads] dec)
                  pusher-id)  :threads))
      (error (AssertionError. (format "Thread %s not found in thread list: %s" pusher-id @online-messangers))))))

(defn message-sender-factory [async?]
  (let [delete-message (:delete @g/hook-action)
        log-message (:log-message-delivery @g/hook-action)
        log-and-delete (if (nil? log-message)
                         (fn [input _ _] (delete-message (:id input)))
                         (fn [input status body]
                           (delete-message (:id input))
                           (log-message input status body)))
        reschedule-message (:reschedule @g/hook-action)]
    (fn [in out ^String id]
      (let [local-channel (when async? (chan))
            pusher (pusher-factory async?)
            write-channel-callback (when async? (write-channel-callback-factory local-channel))]
        (timbre/with-merged-config
          {:appenders {:println {:enabled? false}
                       :spit (appenders/spit-appender {:fname (str "log/" ((str/split id #"/" 2) 0) ".log")})}}
          (reportf "%s:Message sender configured for %s mode" id (if (nil? local-channel) "sync" "async"))
          (go
            (loop [input (<! in)]
              (when-not (nil? input)
                (if (string? input)
                  (when (= input fetch-marker)
                    (>! out  fetch-marker) (recur  (<! in))) ; exit on any string exept "FETCH"
                  (do (debug  id ":Send message:"  (:id input) "Attempt:" (:attempt input))
                      (let [{:keys [error status body]}   (if async?
                                                            (do (pusher input id write-channel-callback)
                                                                (<! local-channel))
                                                            (pusher input id))]
                        (debug  id ":Send result for message "  (:id input) ":status:" status ",body:" body)
                        (when  error
                          (fatal "Failed, exception: error " error " in attempt to send " input))
                          ;(do
                               ;(debug "Attempt: " (:attempt input) "=1? " (= (:attempt input) 1))
                        (if (or (= (:attempt input) 1)
                                (= status http-errors/OK))
                              ;(delete-message (:id input))
                          (log-and-delete input status body)
                          (reschedule-message (:id input)))
                        (recur (<! in));)
                        )))))
            (exit-thread id)
            (when (some? local-channel) (close! local-channel))))))))